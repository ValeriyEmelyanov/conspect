package bitwise;

public class Solution {

    /**
     * Изменяет значение одного бита заданного целого числа на противоположное.
     * (Для работы с битовыми полями)
     * Биты нумеруются от младшего (индекс 1) к старшему (индекс 32)
     * Объяснение:
     * - чтобы поменять знаки битов на противоположные,
     *   необходимо использовать Исключающее ИЛИ (XOR) ' ^ ' и битовую маску,
     * - т.к. нужно поменять знак всего 1 бита в числе на противоположный,
     *   берем число 1 в двоичной системе счисления (00000001) и двигаем единичку на позицию,
     *   равную индексу бита, знак которого мы собираемся менять на противоположный,
     *   для этого используем логический сдвиг влево: 1 << bitIndex - 1,
     *   -1 потому что нумерация с 1, а не с 0.
     *
     * @param value    изменяемое число
     * @param bitIndex номер бита
     * @return измененное число
     */
    public static int flipBit(int value, int bitIndex) {
        int bit = 1 << bitIndex - 1;
        return value ^ bit;
    }

    /**
     * Проверяет, является ли заданное число по абсолютной величине степенью двойки.
     * Объяснение:
     *   В числе 2 в степени n в единицу выставлен только (n+1)-й бит.
     *   Допустим, число k — два в степени n. В числе k в единицу выставлен (n+1)-й бит.
     *   Тогда в числе k-1 в единицу будут выставлены все биты от 1 до n.
     *   Если с такими числами выполнить побитовое ИЛИ, то в результате должен получиться 0.
     * Например:
     *   32 & 31 == 0 //true
     *
     *   100000
     *   &
     *   011111
     *   =
     *   000000
     *
     * @param value проверяемое число
     * @return Истина, если абосолютная величина числа является степенью двойки
     */
    public static boolean isPowerOfTwo(int value) {
        if (value == 0) {
            return false;
        }
        int absValue = Math.abs(value);
        return (absValue & (absValue - 1)) == 0;
    }
}
